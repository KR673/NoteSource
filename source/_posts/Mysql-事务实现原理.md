---
title: Mysql-事务实现原理
date: 2020-01-08 23:56:28
tags: mysql
---

[toc]

## 1. 事务的档四种隔离级别

* **读未提交** : 一个事务可以读到另一个事务没有提交的数据
* **读已提交** : 一个事务可以读到另一个事务已提交的数据
* **可重复读** : 只读在该事务开始之前的数据
* **串行化** : 所有事务都是串行的

## 2. mysql中数据查询与更新过程

### 2.1 查询过程

![](https://mynoteimg.oss-cn-beijing.aliyuncs.com/20200109002655.png)
**mysql8中已经没有查询缓存, 直接查询内存中缓存的数据**

### 2.2 更新过程

**首先查询对应的过程也会执行一边**
![](https://mynoteimg.oss-cn-beijing.aliyuncs.com/20200109002601.png)

## 3. 事务实现原理

### 3.1 读未提交

“读未提交”隔离级别下直接返回记录上的最新值，这里的最新值指的是**缓冲池(内存)**中的值, 因为更新的时候是**直接更新的内存**,不管有没有提交, 只是把提交状态记录在redo-log里


### 3.2 读已提交及可重复读

这两个在实现上类似, 数据库里面会创建一个**视图**(快照)，访问的时候**以视图的逻辑结果为准**。
> 这里的视图**不是虚拟表**, 而是InnoDB 在实现 MVCC 时用到的**一致性读视图**，即 *consistent read view*, 其**没有物理结构**,是在需要的时候根据当前版本和 undo log **计算出来的**。

InnoDB 里面每个事务有一个**唯一**的事务ID，叫作 transaction id. **每行数据也都是有多个版本的**。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id赋值给这个数据版本的事务ID，记为 row trx_id。之前每个版本的值都可以根据最后一个值加上回滚日志计算获得, 也就是说之前版本的值并不是真实存在的

### 3.2.1 读提交

> 视图是在每个 SQL 语句开始执行的时候创建的

### 3.2.2 可重复读

> 视图是在事务启动时创建的，整个事务存在期间都用这个视图。

InnoDB 为每个事务都构造了一个数组，用来保存在这个事务启动瞬间，已经存在的**已启动但还没提交的所有事务**的ID.
数组里面事务ID的最小值记为**低水位**，当前系统里面已经创建过的事务 ID 的最大值加 1 记为**高水位**

此时, 事务ID针对这个数组有三种情况:
1. 小于低水位，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是**可见**的；
2. 大于高水位，表示这个版本是由将来启动的事务生成的，是肯定**不可见**的；
3. 在低水位和高水位之间，又包括两种情况
   * 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，**不可见**；
   * 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，**可见**。

### 3.3 串行化

“串行化”隔离级别下直接用加锁的方式来避免并行访问
