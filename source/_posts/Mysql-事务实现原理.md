---
title: MySQL-事务实现原理
date: 2020-01-08 23:56:28
tags: mysql
---

[toc]

## 1. 事务的档四种隔离级别

* **读未提交** : 一个事务可以读到其他事务没有提交的数据
* **读已提交** : 一个事务可以读到其他事务已提交的数据
* **可重复读** : 只读在该事务开始这个时刻之前的数据
* **串行化** : 所有事务都是串行的

## 2. mysql中数据查询与更新过程

### 2.1 查询过程

![](https://mynoteimg.oss-cn-beijing.aliyuncs.com/20200109002655.png)
**mysql8中已经没有查询缓存, 直接查询内存中缓存的数据**

### 2.2 更新过程

**首先查询对应的过程也会执行一边**
![](https://mynoteimg.oss-cn-beijing.aliyuncs.com/20200109002601.png)

## 3. 事务实现原理

### 3.1 读未提交

“读未提交”隔离级别下直接返回记录上的最新值，这里的最新值指的是**缓冲池(内存)**中的值, 因为更新的时候是**直接更新的内存**,不管有没有提交, 只是把提交状态记录在redo-log里


### 3.2 读已提交及可重复读

这两个在实现上类似, 数据库里面会创建一个**视图**(快照)，访问的时候**以视图的逻辑结果为准**。
> 这里的视图**不是虚拟表**, 而是InnoDB 在实现 MVCC 时用到的**一致性读视图**，即 *consistent read view*, 其**没有物理结构**,是在需要的时候根据当前版本和 undo log **计算出来的**。

InnoDB 里面每个事务有一个**唯一**的事务ID，叫作 transaction id. **每行数据也都是有多个版本的**。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id赋值给这个数据版本的事务ID，记为 row trx_id。之前每个版本的值都可以根据最后一个值加上回滚日志计算获得, 也就是说之前版本的值并不是物理上真实存在的, 只是逻辑上存在的

#### 3.2.1 可重复读

> 视图是在事务启动时创建的，整个事务存在期间都用这个视图。

InnoDB 为每个事务都构造了一个数组，用来保存在这个事务启动瞬间，已经存在的**已启动但还没提交的所有事务**的ID.
数组里面事务ID的最小值记为**低水位**，当前系统里面已经创建过的事务 ID 的最大值加 1 记为**高水位**

**如何保证一个事务的执行期间看到的数据是一致的呢?**,就要由当前的事务ID针对以下三种情况判断: 

> 一个事务更新内存中的一条记录的时候,会同时在数据行中记录下更新事务的ID(也可以看做是版本号), 当前事务就是用当前数据中记录的ID与之前创建的数组做比较

1. 小于低水位，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是**可见**的；
2. 大于高水位，表示这个版本是由将来启动的事务生成的，是肯定**不可见**的；
3. 在低水位和高水位之间，又包括两种情况
   * 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，**不可见**；
   * 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，**可见**。

#### 3.2.2 读提交

> 视图是在每个 SQL 语句开始执行的时候创建的(**需要注意这个创建时间**)

**以下当前均为猜想, 未验证**

由目前的理解,
先反证一下, 如果读提交同样也是从事务创建的时间创建视图, 当执行查询语句的时候:

1. 可以判断出当前事务创建之前提交的数据
2. 可以判断出当前事务创建的时候对应事务的状态, (提交与未提交)
3. 可以判断出当前事务创建之后**更新**的数据, 但是此时没有办法通过这个快照判断出这个数据是否已提交

所以此时如果通过在查询语句开始的时候创建视图, 从而最大承度此时包含未提交与已提交的所有事务, 也即是最大程度的保证不会出现高水位之后的数据
 

### 3.3 串行化

“串行化”隔离级别下直接用加锁的方式来避免并行访问


## 参考:

1. [MySQL实战45讲](https://time.geekbang.org/column/article/68963?code=4WJqZ1Li-NcKqeoaSUYtndaTkiX07wVYoGc8y9Fh9z8%3D)